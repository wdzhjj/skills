###Socket编程

	socket 是“套接字”的意思，学习 socket 编程，也就是学习计算机之间如何通信，并用编程语言来实现它。
	socket 通信技术就是两台联网的计算机之间交换数据的技术
	可以通过 socket() 函数来创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：

    用 read() 读取从远程计算机传来的数据；
    用 write() 向远程计算机写入数据。

	
#### 套接字类型
	 DARPA Internet 地址（Internet 套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25 套接字）
	 
	 Internet 套接字：
	 1、流格式套接字（SOCK_STREAM）：面向连接的套接字
	 SOCK_STREAM 是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。
	 SOCK_STREAM 有以下几个特征：

		数据在传输过程中不会消失；
		数据是按照顺序传输的；
		数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。
		
	 使用了TCP协议	（The Transmission Control Protocol，传输控制协议）
		
	2、数据报格式套接字（SOCK_DGRAM）	：无连接的套接字
		计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。
		因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。
		可以将 SOCK_DGRAM 比喻成高速移动的摩托车快递，它有以下特征：
			强调快速传输而非传输顺序；
			传输的数据可能丢失也可能损毁；
			限制每次传输的数据大小；
			数据的发送和接收是同步的（有的教程也称“存在数据边界”）。

		总之，数据报套接字是一种不可靠的、不按顺序传递的、以追求速度为目的的套接字。
		数据报套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。
		
		
	两种套接字各有优缺点：
    无连接套接字传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险；
    有连接套接字非常可靠，万无一失，但是传输效率低，耗费资源多。
	两种套接字的特点决定了它们的应用场景，有些服务对可靠性要求比较高，
		必须数据包能够完整无误地送达，那就得选择有连接的套接字（TCP 服务），
		比如 HTTP、FTP 等；而另一些服务，并不需要那么高的可靠性，效率和实时才是它们所关心的，那就可以选择无连接的套接字（UDP 服务），比如 DNS、即时聊天工具等。

	
#### OSI模型
		
		OSI 模型把网络通信的工作分为 7 层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。
		两台计算机进行通信时，必须遵守以下原则：

			必须是同一层次进行通信，比如，A 计算机的应用层和 B 计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。
			每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。
			数据只能逐层传输，不能跃层。
			每一层可以使用下层提供的服务，并向上层提供服务。

		
		
#### IP MAC地址 端口号
		IP地址是 Internet Protocol Address 的缩写，译为“网际协议地址”。
		一台计算机可以拥有一个独立的 IP 地址，一个局域网也可以拥有一个独立的 IP 地址（对外就好像只有一台计算机）。对于目前广泛使用 IPv4 地址，它的资源是非常有限的，一台计算机一个 IP 地址是不现实的，往往是一个局域网才拥有一个 IP 地址。
		
		MAC地址
		真正能唯一标识一台计算机的是 MAC 地址，每个网卡的 MAC 地址在全世界都是独一无二的。
		计算机出厂时，MAC 地址已经被写死到网卡里面了，局域网中的路由器/交换机会记录每台计算机的 MAC 地址。 
		
		MAC 地址是 Media Access Control Address 的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address）。
		
		端口号：
			有了IP地址和MAC地址，虽然可以找到目标计算机，但仍然不能通信
			一台计算机可以同时提供多种网络服务
				例如 Web 服务（网站）、FTP 服务（文件传输服务）、SMTP 服务（邮箱服务）等
			只有IP和MAC，计算机虽然可以正确接收数据包，却不知道要将数据包交给哪个网络程序来处理，所以通讯失败
		
			区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号(Port Number)
			Port 是一个虚拟的，逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同编号，就是端口号
		
		
		
#### TCP数据报结构 和 三次握手
		TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接
		
		TCP数据报结构
			1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。
			2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。
			3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：

				URG：紧急指针（urgent pointer）有效。
				ACK：确认序号有效。
				PSH：接收方应该尽快将这个报文交给应用层。
				RST：重置连接。
				SYN：建立一个新连接。
				FIN：断开一个连接。

		三次握手
			客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。
			三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。
		
		TCP 是面向连接的传输协议，建立连接时要经过三次握手，断开连接时要经过四次握手，中间传输数据时也要回复 ACK 包确认，多种机制保证了数据能够正确到达，不会丢失或出错。
		UDP 是非连接的传输协议，没有建立连接和断开连接的过程，它只是简单地把数据丢到网络中，也不需要 ACK 包确认。
		
		UDP 传输数据就好像我们邮寄包裹，邮寄前需要填好寄件人和收件人地址，之后送到快递公司即可，但包裹是否正确送达、是否损坏我们无法得知，也无法保证。UDP 协议也是如此，它只管把数据包发送到网络，然后就不管了，如果数据丢失或损坏，发送端是无法知道的，当然也不会重发。
			如果只考虑可靠性，TCP 的确比 UDP 好。但 UDP 在结构上比 TCP 更加简洁，不会发送 ACK 的应答消息，也不会给数据包分配 Seq 序号，所以 UDP 的传输效率有时会比 TCP 高出很多，编程中实现 UDP 也比 TCP 简单。

		UDP 的可靠性虽然比不上TCP，但也不会像想象中那么频繁地发生数据损毁，在更加重视传输效率而非可靠性的情况下，UDP 是一种很好的选择。比如视频通信或音频通信，就非常适合采用 UDP 协议；
			通信时数据必须高效传输才不会产生“卡顿”现象，用户体验才更加流畅，如果丢失几个数据包，视频画面可能会出现“雪花”，音频可能会夹带一些杂音，这些都是无妨的。
		
		
		
		
		
		
		
		
		
		
		
		
		
