####  并发控制
	只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题
	设计良好的系统会通过锁来防止数据破坏。
	读写锁
		在处理并发读或写时，可以通过实现一个由两种类型的锁组成的系统来解决问题
		通常被成为 共享锁 和 排他锁，也叫 读锁 和 写锁
		读锁是共享的，相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，互不干扰
		写锁是排他的，一个写锁会阻塞其他的写锁和读锁，处于安全策略的考虑
		只有这样，才能确保在给定时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同资源
	锁粒度
		一种提高共享资源并发性的方式就是让锁定对象更有选择性。
		尽量只锁定需要修改的部分数据，而不是所有的资源
		锁定的数据量越少，则系统的并发成都越高，只要互相不冲突即可
		问题是锁也要小号资源，锁的各种操作（获得锁，检查锁是否删除，释放锁），会增加系统开销
	策略锁
		在锁的开销和数据安全性之间寻求平衡，这种平衡也会影响到性能
		一般都是在表上施加行级锁(row-level lock)，并以各种复杂的方式来实现，在锁较多下提供更好的性能
	表锁
		最基本，开销最小的策略
		会锁定整张表，进行写操作前，需要先获得写锁，阻塞其他用户对该表的所有读写操作
		没有写锁时，其他读取的用户才能获得读锁，读锁之间不阻塞
	行级锁
		可以最大程度地支持并发处理，同时带来最大的锁开销 InnoDB

#### 事务
	一组原子性的SQL查询，或者说一个独立的工作单元
	如果数据库引擎能成功对数据库应用该组查询的全部语句，那么就执行该组查询
	事务内的语句，要么全部执行成功，要么全部执行失败
	START TRANSACTION;
	SELECT balance from checking where customer_id = 1;
	update checking set balance = balance - 200 where customer_id = 1;
	update savings set balance  = balance + 200 where customer_id = 1;
	COMMIT;
	事务特性：ACID
		A 原子性 atomicity
		C 一致性 consistency
		I 隔离性 isolation
		D 持久性 durability
	实现ACID的数据库，需要更强的CPU处理能力，更大的内存和更多的磁盘空间
	隔离级别
		READ UNCOMMITTED 提交未读
		READ COMMITTED   提交读
		REPEATABLE READ  可重复度
		SERIALIZABLE     可串行化
	死锁
		两个或者多个事务在统一资源上相互占用，并请求锁定对方占用的资源，从来导致恶性循环
		多个事务试图以不同的顺序锁定资源时，就是产生死锁
		InnoDB目前的处理死锁方法是，将持有最少行级排他锁的事务进行回滚
		死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁
	自动提交 InnoDB
		mysql默认采用自动提交模式。
		不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作
		show variables like 'autocommit'  1/on 表示启用


#### 数据类型优化
	选择正确的数据类型对于获得高性能至关重要
		一般情况下，尽量使用正确存储数据最小的数据类型
			因为他们占用更少的磁盘，内存和cpu缓存，并且处理时需要的CPU周期也更少
		尽量避免 NULL
			通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值
			因为可为NULL的列是的索引，索引统计和值都比较复杂
			可为NULL的列会使用更多的存储空间，在MYSQL里也需要特殊处理，每个索引记录需要一个
			额外的字节
		varchar 与 char
			VARCHAR 用于存储可变长字符串，是最常见的字符串数据类型
			它比定长更节省空间，仅用必要的空间。
			需要使用1个或两个额外字节记录字符串的长度，最大长度小于等于255，使用1个字节
			CHAR 类型是定长的：MYSQL总是更具定义的字符串长度分配足够的空间。
			适合存储河段的字符串，或者所有值都接近同一个长度。（MD5密码）
	范式与 反范式
		范式的优点：
			更新操作比反范式化要快
			当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
			范式化的表通常更小，可以 更好的放在内存里，所以执行操作会更快
			很少有多余的数据
			反范式可以很好的避免关联
	
	
#### 索引
	现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。
	索引的类型
		B-Tree 索引
			大部分使用b-tree数据结构来存储数据
			通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同
			B-Tree索引能够加快访问速度，存储引擎不再需要进行全表扫描来获取需要的数据
			取而代之的是从索引的根节点 开始进行搜索
			因为索引树中的节点是有序的，所以除了按值查找之外，还可以用于查询中的order by操作
		哈希索引
			基于哈希表实现，只有精确匹配索引的所有列的查询才有效
			对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)，这是一个比较小的值
			哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针
	优点：
		大大减少了服务器需要扫描的数据量
		帮助服务器避免排序和临时表
		可以将随机I/O变为顺序I/O
	高性能的索引策略
		独立的列
			如果查询中的列不是独立的，则mysql就不会使用索引
				where actor_id+1 = 5;
				where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
		前缀索引和索引选择性
		多索引列
			当服务器对多个索引做相交操作时，意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
			当服务器需要对多个索引做联合操作时(or条件),通常需要耗费大量的CPU和内存资源在算法的缓存/排序和合并
			优化器不会把上面的内容作为 查询成本，优化器只关心随机页面读取
		选择合适的索引列顺序	
			结果数量更小的索引列应放到多的前面
		聚簇索引
			并不是一种单独的索引类型，是一种数据存储方式
			当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中(leaf page)
			聚簇 表示数据行和相邻的键值紧凑的存储在一起
			无法同时把数据行放在两个不同的地方，索引一个表只能有一个聚簇索引
			优点：	
				可以把相关数据保存在一起。
				数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中
				使用覆盖索引扫描的查询可以直接使用页节点中的主键值
		覆盖索引
			如果一个索引包含所有需要查询的字段的值=》覆盖索引
			不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，哈希/空间/全文索引不储存索引列的值
			mysql只能使用B-Tree索引做覆盖索引，页并不是索引引擎都支持覆盖索引
		使用索引扫描来做排序
		压缩索引	
		冗余和重复索引
		索引和锁
			InnoDB只有在访问行的时候才会对其枷锁，而索引能够减少Innodb访问的行数，从而减少锁的数量
			但这只有当InnoDB在存储引擎能够过滤掉所有不需要的行时才有效
	
	
#### 查询性能优化
		慢查询
			是否向数据库请求了不需要的数据
				查询不需要的记录
				多表关联时返回全部列
				总是取出全部列
				重复查询
			是否在扫描额外的记录
				explain=》rows  加不加索引差距很大
		重构查询的方式
			一个复杂查询 还是 多个简单查询
			切分查询
			分解关联查询
		查询执行的基础
			Mysql客户端 / 服务器通信协议
			查询缓存
			查询优化处理
				将外连接转换成内连接
				并不是所有OUTER JOIN语句都必须以外连接的方式执行
				使用等价变换规则
				优化 COUNT() MIN() MAX()
				预估并转化为常数表达式
				覆盖索引扫描
				子查询优化
				提前终止查询
				等值传播
				使用in 替代or
		优化特性类型的查询
			优化count()查询 
				count()是一个特殊函数，可以统计某个列值的数量，也可以统计行数
				如果count()括号中指定了列或者列的表达式，统计的是这个表达式有值的结果数
			优化limit分页
			避免重复查询刚刚更新的数据
			统计更新和插入的数量
			确定取值的顺序
			用户自定义变量	
			
			
#### 高级特性
		1 分区表
			主要目的是将数据按照一个较粗的粒度分在不同秒中，这样做可以将相关数据放在一起
			应用场景
				表非常大以至于无法全部放在内存中，或者只在表的最后部分有热点数据，其他为历史数据
				分区表更容易维护。可以对一个独立分区进行优化检查修复等操作
				可以分布在不同物理设备上，从而高效地利用多个硬件设备
				避免某些特殊的瓶颈。（单个索引的互斥访问，ext3文件系统的inode锁竞争等）
				可以备份和恢复独立的分区
			限制
				一个表最多只能有1024个分区
				某些场景中可以直接使用列来进行分区
				分区表中无法使用外键约束
				如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
			原理
				由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以也可以直接访问各个分区
			类型
				根据键值进行分区，减少InnoDB的互斥量竞争
				使用数学模函数来分区，将数据轮询放入不同的分区。
				根据时间将最近的热点数据集中存放。需要时间戳
			可能会遇到的问题
				NULL值会使分区过滤无效
				分区列和索引列不匹配
				选择分区的成本可能会很高
				打开并所著所有底层表的成本高
				维护分区成本
		2.视图
			本身是一个虚拟表，不存放任何数据
			在使用SQL语句访问视图时，它返回的数据是mysql从其他表中生成的
			CREATE VIEW Oceania AS
				SELECT * FROM Country WHERE contient='Oceania'
				WITH CHECK OPTION
			=> select code,name from Oceania where name='china';	
		3.Mysql内部存储代码
			允许通过触发器/存储过程/函数的形式来存储代码
			优点
				服务器内部执行，离数据最近，节省带宽和网络延迟
				代码重用，可以方便统一业务规则
				可以简化代码的维护和版本更新
				提升安全，提供更细粒度的权限控制
				服务器端可以缓存存储过程的执行计划
				备份维护都可以在服务器端完成
				可以在应用开发和数据库开发人员之间更好的分工
			触发器：
				可以让你在执行INSERT/UPDATE/DELETE的时候，执行一些特定的操作
				可以指定是在SQL语句执行前出发还是在执行后出发
				* 每一个表的每一个事件，最多只能定义一个触发器
				* 只支持基于行的出发
				** 可能掩盖服务器背后的工作
				** 问题难以排查
				** 可能导致死锁和锁等待
			事件：
				类似于linux的定时任务，完全在mysql内部实现
				时间在一个独立时间调度线程中被初始化，这个线程和处理连接的线程没有任何关系
				CREATE EVENT optimize_somedb on SCHEDULE EVERY 1 WEEK
				DO 
				BEGIN
					DECLARE CONTINUE HANLDER FOR SQLEXCEPTION
						BEGIN END;
					IF GET_LOCK(‘somedb’,0) THEN
						DO CALL optimize_tables('somedb');
					END IF;
					DO RELEASE_LOCK('somedb');
				END	
	
	
	
#### 复制
		复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。
		一台主库的数据可以同步到多台备库上，备库本身也可以被配置秤另外一台服务器的主库
		两种复制方式：
			基于行的复制和基于语句的复制
			两种方式都是通过在主库上记录二进制日志/在备库重放日志的方式来实现异步的数据复制
		复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，处于备份或即使从崩溃中修复，是必要开销
		复制解决的问题
			数据分布
			负载均衡
				复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化
			备份
			高可用性和故障切换
			mysql升级测试
		工作原理
			1/ 在主库上把数据更改记录到二进制日志 Binary Log中
			2/ 备库将主库上的日志复制到自己的中继日志 Relay Log中
			3/ 备库读取中继日志中的事件，将其重放到备库数据之上
		复制配置
			1/ 在每台服务器上创建复制账号
			2/ 配置主库和备库
			3/ 通知备库连接到主库并从主库复制数据
			
#### 扩展mysql
		向上扩展（垂直扩展）
			购买更多性能强悍的硬件
		向外扩展（横向/水平扩展）：
			复制/拆分/数据分片
				通过复制将数据分发到多个服务器上，然后将备库用于读查询
				将工作负载分布到多个”节点“
				* 一个主一主复制双机结构，拥有一个主动服务器和被动服务器
				* 一个主库和多个备库
				* 一个主动服务器，并使用分布式复制快设备DRBD 作为备用服务器
				* 一个基于存储区域网络 SAN 的集群
				
			拆分：
				按功能拆分
				（论坛/新闻/支持）
			数据分片：
				把数据分割秤一块，存储到不同的节点中
				数据分片在和某些类型的按功能划分联合使用时非常游泳。
				
		向内扩展
			处理不断增长的数据和负载最简单的方法是对不再需要的数据进行归档和清理
			对应用的影响/要归档的行/维护数据一致性/避免数据丢失/接触归档
			
				
		负载均衡		
			在一个服务器集群中尽可能地平均负载量。
			在服务器前端设置一个负载均衡器。然后负载均衡器请求的连接路由到最空闲的可用服务器
			目的：
				* 可扩展性
				* 高效性
				* 可用性
				* 透明性
				* 一致性
			

####  EXPLAIN			
		列：
			id：
				总是包含一个编号，标识SELECT所属的行
				如果在语句中没有子查询或联合，指挥有位移的select，于是每一行在这个列中都将显示一个1
			select_type:
				显示了对应行是简单还是复杂select
				SIMPLE意味着不包括子查询和UNION。如果有字部份，在外层标记为PRIMARY
					SUBQUERY
						包含在SELECT 列表中的子查询中的SELECT
					DERIVED 
						标识包含在FROM子句中的子查询中的SELECT	
					UNION
						在UNION中的第二个和随后的SELECT被标记为UNION
					UNION RESULT
						用来从UNION的匿名临时表检索结果的SLECT被标记为UNION RESULT
						
			table：
				显示了对应正在访问哪个表
				
			type：	
				
				
				
				
				
				
				
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	