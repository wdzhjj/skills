####  并发控制
	只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题
	设计良好的系统会通过锁来防止数据破坏。
	读写锁
		在处理并发读或写时，可以通过实现一个由两种类型的锁组成的系统来解决问题
		通常被成为 共享锁 和 排他锁，也叫 读锁 和 写锁
		读锁是共享的，相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，互不干扰
		写锁是排他的，一个写锁会阻塞其他的写锁和读锁，处于安全策略的考虑
		只有这样，才能确保在给定时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同资源
	锁粒度
		一种提高共享资源并发性的方式就是让锁定对象更有选择性。
		尽量只锁定需要修改的部分数据，而不是所有的资源
		锁定的数据量越少，则系统的并发成都越高，只要互相不冲突即可
		问题是锁也要小号资源，锁的各种操作（获得锁，检查锁是否删除，释放锁），会增加系统开销
	策略锁
		在锁的开销和数据安全性之间寻求平衡，这种平衡也会影响到性能
		一般都是在表上施加行级锁(row-level lock)，并以各种复杂的方式来实现，在锁较多下提供更好的性能
	表锁
		最基本，开销最小的策略
		会锁定整张表，进行写操作前，需要先获得写锁，阻塞其他用户对该表的所有读写操作
		没有写锁时，其他读取的用户才能获得读锁，读锁之间不阻塞
	行级锁
		可以最大程度地支持并发处理，同时带来最大的锁开销 InnoDB

#### 事务
	一组原子性的SQL查询，或者说一个独立的工作单元
	如果数据库引擎能成功对数据库应用该组查询的全部语句，那么就执行该组查询
	事务内的语句，要么全部执行成功，要么全部执行失败
	START TRANSACTION;
	SELECT balance from checking where customer_id = 1;
	update checking set balance = balance - 200 where customer_id = 1;
	update savings set balance  = balance + 200 where customer_id = 1;
	COMMIT;
	事务特性：ACID
		A 原子性 atomicity
		C 一致性 consistency
		I 隔离性 isolation
		D 持久性 durability
	实现ACID的数据库，需要更强的CPU处理能力，更大的内存和更多的磁盘空间
	隔离级别
		READ UNCOMMITTED 提交未读
		READ COMMITTED   提交读
		REPEATABLE READ  可重复度
		SERIALIZABLE     可串行化
	死锁
		两个或者多个事务在统一资源上相互占用，并请求锁定对方占用的资源，从来导致恶性循环
		多个事务试图以不同的顺序锁定资源时，就是产生死锁
		InnoDB目前的处理死锁方法是，将持有最少行级排他锁的事务进行回滚
		死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁
	自动提交 InnoDB
		mysql默认采用自动提交模式。
		不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作
		show variables like 'autocommit'  1/on 表示启用


#### 数据类型优化
	选择正确的数据类型对于获得高性能至关重要
		一般情况下，尽量使用正确存储数据最小的数据类型
			因为他们占用更少的磁盘，内存和cpu缓存，并且处理时需要的CPU周期也更少
		尽量避免 NULL
			通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值
			因为可为NULL的列是的索引，索引统计和值都比较复杂
			可为NULL的列会使用更多的存储空间，在MYSQL里也需要特殊处理，每个索引记录需要一个
			额外的字节
		varchar 与 char
			VARCHAR 用于存储可变长字符串，是最常见的字符串数据类型
			它比定长更节省空间，仅用必要的空间。
			需要使用1个或两个额外字节记录字符串的长度，最大长度小于等于255，使用1个字节
			CHAR 类型是定长的：MYSQL总是更具定义的字符串长度分配足够的空间。
			适合存储河段的字符串，或者所有值都接近同一个长度。（MD5密码）
	范式与 反范式
		范式的优点：
			更新操作比反范式化要快
			当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
			范式化的表通常更小，可以 更好的放在内存里，所以执行操作会更快
			很少有多余的数据
			反范式可以很好的避免关联
	
	
#### 索引
	现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。
	索引的类型
		B-Tree 索引
			大部分使用b-tree数据结构来存储数据
			通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同
			B-Tree索引能够加快访问速度，存储引擎不再需要进行全表扫描来获取需要的数据
			取而代之的是从索引的根节点 开始进行搜索
			因为索引树中的节点是有序的，所以除了按值查找之外，还可以用于查询中的order by操作
		哈希索引
			基于哈希表实现，只有精确匹配索引的所有列的查询才有效
			对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)，这是一个比较小的值
			哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针
	优点：
		大大减少了服务器需要扫描的数据量
		帮助服务器避免排序和临时表
		可以将随机I/O变为顺序I/O
	高性能的索引策略
		独立的列
			如果查询中的列不是独立的，则mysql就不会使用索引
				where actor_id+1 = 5;
				where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
		前缀索引和索引选择性
		多索引列
			当服务器对多个索引做相交操作时，意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
			当服务器需要对多个索引做联合操作时(or条件),通常需要耗费大量的CPU和内存资源在算法的缓存/排序和合并
			优化器不会把上面的内容作为 查询成本，优化器只关心随机页面读取
		选择合适的索引列顺序	
			结果数量更小的索引列应放到多的前面
		聚簇索引
			并不是一种单独的索引类型，是一种数据存储方式
			当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中(leaf page)
			聚簇 表示数据行和相邻的键值紧凑的存储在一起
			无法同时把数据行放在两个不同的地方，索引一个表只能有一个聚簇索引
			优点：	
				可以把相关数据保存在一起。
				数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中
				使用覆盖索引扫描的查询可以直接使用页节点中的主键值
		覆盖索引
			如果一个索引包含所有需要查询的字段的值=》覆盖索引
			不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，哈希/空间/全文索引不储存索引列的值
			mysql只能使用B-Tree索引做覆盖索引，页并不是索引引擎都支持覆盖索引
		使用索引扫描来做排序
		压缩索引	
		冗余和重复索引
		索引和锁
			InnoDB只有在访问行的时候才会对其枷锁，而索引能够减少Innodb访问的行数，从而减少锁的数量
			但这只有当InnoDB在存储引擎能够过滤掉所有不需要的行时才有效
	
	
#### 查询性能优化
		慢查询
			是否向数据库请求了不需要的数据
				查询不需要的记录
				多表关联时返回全部列
				总是取出全部列
				重复查询
			是否在扫描额外的记录
				explain=》rows  加不加索引差距很大
		重构查询的方式
			一个复杂查询 还是 多个简单查询
			切分查询
			分解关联查询
		查询执行的基础
			Mysql客户端 / 服务器通信协议
			查询缓存
			查询优化处理
				将外连接转换成内连接
				并不是所有OUTER JOIN语句都必须以外连接的方式执行
				使用等价变换规则
				优化 COUNT() MIN() MAX()
				预估并转化为常数表达式
				覆盖索引扫描
				子查询优化
				提前终止查询
				等值传播
				使用in 替代or
				
			
			
			
			
			
			
			
			
			
			
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	