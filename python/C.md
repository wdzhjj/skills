### C语言知识
#### 关键字
		auto        声明自动变量
		break		跳出当前循环
		case 		开关语句分支
		char 		声明字符型变量或函数返回值类型
		const		声明只读变量
		continue    结束当前循环，开始下一轮循环
		default		开关语句中的其他分支
		do			循环语句的循环体
		double		声明双精度浮点型变量或函数返回值类型
		else		条件语句否定分支
		enum		声明枚举类型
		extern		声明变量或函数是在其他文件或本文件的其他位置定义
		float		声明浮点型变量或函数返回值类型
		int    		声明整型变量或函数
		long		声明长整型变量或函数返回值类型
		register	声明寄存器变量
		short		声明短整型变量或函数
		signed		声明有符号类型变量或函数
		sizeof		计算数据类型或变量长度（所占字节数）
		static		声明静态变量
		sturct		声明结构体类型
		typedef		用以给数据类型取别名
		unsigned	无符号类型变量或函数
		union		声明共用体类型
		void		声明函数无返回值或无参数，声明无类型指针
		volatile	说明变量在程序执行中可被隐含的改变
		while		循环语句的循环条件
		
#### 预处理指令及分类 
			C/C++ 程序中的源代码中包含以 # 开头的各种编译指令，这些指令称为预处理指令
		ANSI C 定义的预处理指令主要包括：文件包含、宏定义、条件编译和特殊控制等 4 类。	
		
		1) 文件包含：
			#include 是 C 程序设计中最常用的预处理指令。
			几乎每个需要输入输出的 C 程序，都要包含 #include<stdio.h> 指令，表示把 stdio.h 文件中的全部内容，替换该行指令。		
				尖括号形式：如 #include<math.h>，预处理器直接到系统目录对应文件中搜索 math.h 文件，搜索不到则报错。系统提供的头文件一般采用该包含方式，而自定义的头文件不能采用该方式。
				双引号形式：如 #include"cal.h"，首先到当前工作目录下查找该文件，如果没有找到，再到系统目录下查找。包含自定义的头文件，一般采用该方式。虽然系统头文件采用此方式也正确，但浪费了不必要的搜索时间，故系统头文件不建议采用该包含方式。
		2) 宏定义：包括定义宏 #define 和宏删除 #undef。
			    #define PI 3.1416 //定义无符号宏，或定义符号常量 PI
				#undef PI //删除前面该宏的定义
		3) 条件编译：主要是为了有选择性地执行相应操作，防止宏替换内容（如文件等）的重复包含。常见的条件编译指令有 #if、#elif、#else、#endif、#ifdef、#ifndef。
		4) 特殊控制：ANSI C 还定义了特殊作用的预处理指令，如 #error、#pragma。
			#error：使预处理器输出指定的错误信息，通常用于调试程序。
			#pragma：是功能比较丰富且灵活的指令，可以有不同的参数选择，从而完成相应的特 定功能操作。调用格式为：#pragma 参数。
		
#### 宏定义（无参宏定义和带参宏定义）		
		无参宏定义
		#define 标识符 替换列表
		替换列表可以是数值常量、字符常量、字符串常量等，故可以把宏定义理解为使用标识符表示一常量，或称符号常量。
		1) # 可以不在行首，但只允许它前面有空格符。
		2) 标识符和替换列表之间不能加赋值号 =，替换列表后不能加分号
		3) 由于宏定义仅是做简单的文本替换，故替换列表中如有表达式，必须把该表达式用括号括起来，否则可能会出现逻辑上的“错误”
		4) 当替换列表一行写不下时，可以使用反斜线\作为续行符延续到下一行。
		
		带参宏定义
		#define 标识符(参数1,参数2,...,参数n) 替换列表
		删除宏定义的格式为：
		#undef 标识符
		1) 标识符与参数表的左括号之间不能有空格，否则预处理器会把该宏理解为普通的无参宏定义，故以下是错误的带参宏定义形式。 
		2) 宏替换列表中每个参数及整个替换列表，都必须用一对小括号 () 括起来，否则可能会出现歧义。
		    #define MAX(a,b) ((a)>(b)?(a) : (b))
		
		带参宏定义 VS 函教调用
			调用发生的时间
				在源程序进行编译之前，即预处理阶段进行宏替换；而函数调用则发生在程序运行期间。
			参数类型检查
				函数参数类型检查严格。程序在编译阶段，需要检查实参与形参个数是否相等及类型是否匹配或兼容，若参数个数不相同或类型不兼容，则会编译不通过。
			参数是否需要空间
				函数调用时，需要为形参分配空间，并把实参的值复制一份赋给形参分配的空间中。而宏替换，仅是简单的文本替换，且替换完就把宏名对应标识符删除掉，即不需要分配空间。
			执行速度
				函数在编译阶段需要检查参数个数是否相同、类型等是否匹配等多个语法，而宏替换仅 是简单文本替换，不做任何语法或逻辑检查。
				函数在运行阶段参数需入栈和出栈操作，速度相对较慢。
			代码长度
				由于宏替换是文本替换，即如果需替换的文本较长，则替换后会影响代码长度；而函数不会影响代码长度。

#### 条件编译
			常见的条件编译指令 
			条件编译指令 	说 明
			#if 	如果条件为真，则执行相应操作
			#elif 	如果前面条件为假，而该条件为真，则执行相应操作
			#else 	如果前面条件均为假，则执行相应操作
			#endif 	结束相应的条件编译指令
			#ifdef 	如果该宏已定义，则执行相应操作
			#ifndef 	如果该宏没有定义，则执行相应操作
		
		#if-#else-#endif
			如果#if后的条件表达式为真，则程序段 1 被选中，否则程序段 2 被选中。
			注意，必须使用 #endif 结束该条件编译指令。
		#ifndef-#define-#endif
			#ifndef 标识符
			#define 标识符 替换列表
				//...
			#endif
		一般用于检测程序中是否已经定义了名字为某标识符的宏，如果没有定义该宏，则定义该宏，并选中从 #define 开始到 #endif 之间的程序段；如果已定义，则不再重复定义该符号，且相应程序段不被选中。	
		
		#ifdef-#endif
		#ifdef 标识符
			程序段
		#endif	功能为：如果检测到已定义该标识符，则选择执行相应程序段被选中编译；否则，该程序段会被忽略。
		
		
#### 原码、反码和补码		
		位（bit）是计算机中处理数据的最小单位，其取值只能是 0 或 1。
		字节（Byte）是计算机处理数据的基本单位，通常系统中一个字节为 8 位。即:1 Byte=8 bit。
		正数的原码、反码、补码均相同。
		原码：用最高位表示符号位，其余位表示数值位的编码称为原码。其中，正数的符号位为 0，负数的符号位为 1。
		负数的反码：把原码的符号位保持不变，数值位逐位取反，即可得原码的反码。
		负数的补码：在反码的基础上加 1 即得该原码的补码。
		
		位操作符
		运算符 		功 能 	运算规则
			& 		按位与 	对应位均为 1 时，结果才为 1
			| 		按位或 	两位中只要有一位为 1，结果为 1。
							只有两位同时为 0 时，结果为才为 0。
			^ 		按位异或 	两位相异时，结果为 1;两位相同时，结果为 0。
			<< 		左移 	将运算数的各二进制位均左移若干位，
							高位丢弃（不包括1），低位补 0，每左移一位，相当于该数乘以 2。
			>> 	右移 		将运算数的各二进制位均右移若干位，正数补左补 0，
							负数左补 	1，右边移出的位丢弃。
			~ 	按位取反 	0 变 1,1 变 0。
					

#### 宏和函数的区别				
		 1) 从程序的执行来看
			函数调用会带来额外的开销，它需要开辟一片栈空间，记录返回地址，将形参压栈，从函数返回还要释放栈。这种开销不仅会降低代码效率，而且代码量也会大大增加。而宏定义只在编译前进行，不分配内存，不占运行时间，只占编译时间，因此在代码规模和速度方面都比函数更胜一筹。
		2) 从参数的类型来看
			函数的参数必须声明为一种特定的数据类型，如果参数的类型不同，就需要使用不同的函数来解决，即使这些函数执行的任务是相同的。而宏定义则不存在着类型问题，因此它的参数也是无类型的。也就是说，在宏定义中，只要参数的操作是合法的，它可以用于任何参数类型。
		3) 从参数的副作用来看
			毋庸置疑，在宏定义中，在对宏参数传入自增（或者自减）之类的表达式时很容易引起副作用，尽管前面也给出了一些解决方案，但还是不能够完全杜绝这种情况的发生。与此同时，在进行宏替换时，如果不使用括号完备地保护各个宏参数，那么很可能还会产生意想不到的结果。除此之外，宏还缺少必要的类型检查。而函数却从根本上避免了这些情况的产生。
		4) 从代码的长度来看
			在每次使用宏时，一份宏定义代码的副本都会插入程序中。除非宏非常短，否则使用宏会大幅度地增加程序的长度。而函数代码则只会出现在一个地方，以后每次调用这个函数时，调用的都是那个地方的同一份代码。
		
		
		
#### 常用的标准预定义宏		
		宏 			描 述
		__DATE__ 	丐前源文件的编泽口期，用 “Mmm dd yyy”形式的字符串常量表示
		__FILE__ 	当前源文件的名称，用字符串常量表示
		__LINE__ 	当前源义件中的行号，用十进制整数常量表示，它可以随#line指令改变
		__TIME__ 	当前源文件的最新编译吋间，用“hh:mm:ss”形式的宁符串常量表示
		__STDC__ 	如果今前编泽器符合ISO标准，那么该宏的值为1，否则未定义
		__STDC_VERSION__ 	如果当前编译器符合C89，那么它被定义为199409L;如果符合C99，那么它被定义为199901L:在其他情况下，该宏为宋定义
		__STDC_HOSTED__ 	(C99)如果当前是宿主系统，则该宏的值为1;如果当前是独立系统，则该宏的值为0
		__STDC_IEC_559_ 	(C99)如果浮点数的实现符合IEC 60559标准时，则该宏的值为1，否则为未定义
					
		
#### #include的用法
		#include 命令是预处理命令的一种，预处理命令可以将别的源代码内容插入到所指定的位置；可以标识出只有在特定条件下才会被编译的某一段程序代码；可以定义类似标识符功能的宏，在编译时，预处理器会用别的文本取代该宏。 
		
		插入头文件的内容
		#include 命令告诉预处理器将指定头文件的内容插入到预处理器命令的相应位置。
		    #include <文件名>
			#include "文件名"
		如果需要包含标准库头文件或者实现版本所提供的头文件，应该使用第一种格式
			#include <math.h>               // 一些数学函数的原型，以及相关的类型和宏
		如果需要包含针对程序所开发的源文件，则应该使用第二种格式。采用 #include 命令所插入的文件，通常文件扩展名是 .h，文件包括函数原型、宏定义和类型定义。
		    #include "myproject.h"         // 用在当前项目中的函数原型、类型定义和宏
		
#### #line、#error和#pragma命令，以及_pragma运算符
		定义行号
		编译器会在警告消息、错误消息与调试信息中包含代码所在的行号与所在的源文件名，并提供给调试工具。
		你可以在源代码中利用 #line 命令改变编译器默认指定的文件名与行号信息。
		    #line line_number ["filename"]
		line_number 必须是大于 0 的十进制常量。如下例所示：
			#line 1200 "primary.c"
		程序可以利用标准预定义宏 __LINE__ 和 __FILE__ 来访问当前的行号和文件名设置： 
		
		生成错误消息
		无论是否有实际错误，#error 命令都会让预处理器发出错误消息。
		
		 #pragma 命令
		#pragma 命令是向编译器提供额外信息的标准方法，其格式如下：
			#pragma [tokens]
		如果 #pragma 之后的第一个标记（token）是 STDC，那么该命令就是一个标准 pragma。否则，该 #pragma 命令的作用取决于实现版本。为了保障代码的可移植性，应该尽量少使用 #pragma 命令。		
		
		
		
#### C语言变量定义和赋值
			数据类型  变量名;
		给变量赋值	
			变量名 =  要赋的值;
		二合一
			数据类型  变量名 = 要赋的值;
			int i = 3;
		可以一次性定义多个变量
			int i,j;
			int i=3,j=56;
			
#### C语言变量命名规则
		1) 变量名的开头必须是字母或下划线，不能是数字
		2) 变量名中的字母是区分大小写的。	
		3) 变量名绝对不可以是C语言关键字	
		4) 变量名中不能有空格。	 	变量名是字母、数字、下划线的组合
			
		命名规范	
			1) 禁止取单个字母作为变量名（如 a、b、c、d、i、j、k、m、n……）
			2) 但并不是说就绝对不可以用单个字母，有些变量它本身就是没有含义，我们也不能硬生生给它赋予含义，这时候就可以用单个字母。
			
#### C语言类型自动转换
		自动转换的规则如下
			1) 当参与运算的数据的类型不同时，编译系统会自动先将它们转换成同一类型，然后再进行运算。
			2) 所有的浮点运算都是以双精度进行的。
			3) char 型和 short 型数据参与运算时，必须先转换成 int 型。这也是涉及 CPU 的运行原理的，记住就行了。
			4) 有符号整型和无符号整型混合运算时，有符号型要转换成无符号型，运算的结果是无符号的。
			    int a = -10;
				unsigned b = 5;
				(a+b)>0
			5) 整型和浮点型混合运算时，整型先转换成浮点型，运算的结果是浮点型。
			6) 在赋值运算中，当赋值号两边的数据类型不同时，右边的类型会转换为左边的类型，然后再赋给左边。如果右边数据类型的长度比左边长，那么将会丢失数据，这样就会降低精度，所以编译的时候会产生警告。	
			
#### 代码规范化的七大原则
		1) 空行
			规则一：定义变量后要空行。尽可能在定义变量的同时初始化该变量，即遵循就近原则。如果变量的引用和定义相隔比较远，那么变量的初始化就很容易被忘记。若引用了未被初始化的变量，就会导致程序出错。
			规则二：每个函数定义结束之后都要加空行。
			总规则：两个相对独立的程序块、变量说明之后必须要加空行。比如上面几行代码完成的是一个功能，下面几行代码完成的是另一个功能，那么它们中间就要加空行。这样看起来更清晰。 
			
		2) 空格	
			规则一：关键字之后要留空格。像 const、case 		等关键字之后至少要留一个空格，否则无法辨析关键字。像 if、for、while 等关键字之后应留一个空格再跟左括号(，以突出关键字。

			规则二：函数名之后不要留空格，应紧跟左括号(，以与关键字区别。

			规则三：(向后紧跟；)、,、;这三个向前紧跟；紧跟处不留空格。

			规则四：,之后要留空格。如果;不是一行的结束符号，其后要留空格。

			规则五：赋值运算符、关系运算符、算术运算符、逻辑运算符、位运算符，如 =、==、！=、+=、－=、*=、/=、%=、>>=、<<=、&=、^=、|=、>、<=、>、>=、+、－、*、/、%、&、|、&&、||、<<、>>、^ 等双目运算符的前后应当加空格。

			注意，运算符“%”是求余运算符，与 printf 中 %d 的“%”不同，所以 %d 中的“%”前后不用加空格。

			规则六：单目运算符 !、~、++、－－、－、*、& 等前后不加空格。
			
			规则七：像数组符号[]、结构体成员运算符.、指向结构体成员运算符->，这类操作符前后不加空格。
			
			规则八：对于表达式比较长的 for 语句和 if 语句，为了紧凑起见，可以适当地去掉一些空格。但 for 和 if 后面紧跟的空格不可以删，其后面的语句可以根据语句的长度适当地去掉一些空格
		
		 3) 成对书写
			成对的符号一定要成对书写，如 ()、{}。不要写完左括号然后写内容最后再补右括号，这样很容易漏掉右括号，尤其是写嵌套程序的时候。 		
			
		 4) 缩进
			缩进是通过键盘上的 Tab 键实现的，缩进可以使程序更有层次感。原则是：如果地位相等，则不需要缩进；如果属于某一个代码的内部代码就需要缩进。 	
			
		 5) 对齐
			对齐主要是针对大括号{}说的：

			规则一：{和}分别都要独占一行。互为一对的{和}要位于同一列，并且与引用它们的语句左对齐。
			规则二：{}之内的代码要向内缩进一个 Tab，且同一地位的要左对齐，地位不同的继续缩进。
	
		 6) 代码行
			规则一：一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且便于写注释。

			规则二：if、else、for、while、do 等语句自占一行，执行语句不得紧跟其后。此外，非常重要的一点是，不论执行语句有多少行，就算只有一行也要加{}，并且遵循对齐的原则，这样可以防止书写失误。 	
			
		 7) 注释
			C语言中一行注释一般采用//…，多行注释必须采用/*…*/。	
			
			
#### printf用法大全
		如果在程序中要使用 printf 或者 scanf，那么就必须要包含头文件 stdio.h。因为这两个函数就是包含在该头文件中的。
		输出函数的功能是将程序运行的结果输出到屏幕上，而输入函数的功能是通过键盘给程序中的变量赋值。
			
		printf的格式
			#include <stdio.h>
			int printf(const char *format,...);
		四种格式
		1、printf("字符串\n");
			\n 表示换行，是一个转义字符，n表示new line
			printf 中的双引号和后面的分号必须是在英文输入法下。双引号内的字符串可以是英文，也可以是中文。 
		2、printf("输出控制符",输出参数);
			int i=10;
			printf("%d\n",i);   /*%d是输出控制符，d 表示十进制，后面的 i 是输出参数*/
			return 0;
		这句话的意思是将变量i以十进制输出
			计算机只能执行二进制 0、1 代码，而 0、1 代码本身并没有什么实际的含义，它可以表示任何类型的数据。
			所以输出的时候要强调是以哪种进制形式输出。所以就必须要有“输出控制符”，以告诉操作系统应该怎样解读二进制数据。
			%x就是以十六进制的形式输出
			%o就是以八进制的形式输出
			
		3) printf("输出控制符1 输出控制符2…", 输出参数1, 输出参数2, …);	
			 printf("%d %d\n", i, j);
		4) printf("输出控制符 非输出控制符"，输出参数);	
			凡是以%开头的基本上都是输出控制符。 
			
			输出控制符
			控制符 	说明
			%d 		按十进制整型数据的实际长度输出。
			%ld 	输出长整型数据。
			%md 	m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补以空格，若大于 		m，则按实际位数输出。
			%u 		输出无符号整型（unsigned）。输出无符号整型时也可以用 %d，
					这时是将无符号转换成有符号数，然后输出。但编程的时候最好不要这么写，
					因为这样要进行一次转换，使 CPU 多做一次无用功。
			%c 		用来输出一个字符。
			%f 		用来输出实数，包括单精度和双精度，以小数形式输出。
					不指定字段宽度，由系统自动指定，整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入。
			%.mf 	输出实数时小数点后保留 m 位，注意 m 前面有个点。
			%o 		以八进制整数形式输出，这个就用得很少了，了解一下就行了。
			%s 		用来输出字符串。用 %s 	输出字符串同前面直接输出字符串是一样的。
					但是此时要先定义字符数组或字符指针存储或指向字符串，这个稍后再讲。
			%x（或 %X 或 %#x 或 %#X） 	以十六进制形式输出整数，这个很重要。
			
		%x、%X、%#x、%#X 的区别	
			如果是小写的x，输出的字母就是小写的；如果是大写的X，输出的字母就是大写的；如果加一个#，就以标准的十六进制形式输出。
			不加#容易造成误解。但是如果输出 0x2f 或 0x2F，那么人家一看就知道是十六进制。而且%#x和%#X中，笔者觉得大写的比较好，因为大写是绝对标准的十六进制写法。 
			
		如何输出 %d、\ 和双引号	
			要输出%d只需在前面再加上一个%，要输出\只需在前面再加上一个\，要输出双引号也只需在前面加上一个\即可
			    printf("%%d\n");
				printf("\\\n");
				printf("\"\"\n");
			
			
		scanf的用法	
			1) scanf("输入控制符", 输入参数);
				功能：将从键盘输入的字符转化为“输入控制符”所规定格式的数据，然后存入以输入参数的值为地址的变量中。
				scanf("%d", &i);  //&i 表示变量 i 的地址，&是取地址符
			2) scanf("输入控制符非输入控制符", 输入参数);	
				这种用法几乎是不用的，也建议永远都不要用。
			 scanf("%d%d", &i, &j);	
			虽然 scanf 中没有加任何“非输入控制符”，但是从键盘输入数据时，给多个变量赋的值之间一定要用空格、回车或者 Tab 键隔开，用以区分是给不同变量赋的值。而且空格、回车或 Tab 键的数量不限，只要有就行。一般都使用一个空格。
			
		 使用scanf的注意事项
			1) 参数的个数一定要对应	
			2) 输入的数据类型一定要与所需要的数据类型一致
			3) 在使用 scanf 之前使用 printf 提示输入
			
			
#### C语言数据类型分类
		基本类型
			标准整数类型，以及扩充的整数类型
			实数浮点类型，以及复数浮点类型
		枚举类型
		void类型
		派生类型
			指针类型
			数组类型
			结构类型
		联合类型
		函数类型
		
		整数类型
			C支持5种带符号的整数类型
			signed char 
						 同义词
			int 		 signed,signed int
			short		 short int,signed short,signed short int
			long 		 long int,signed long,signed long int
			long long 	 long long int,signed long long ,signed long long int
			
		    无符号整数类型
							同义词
			_Bool        	bool
			unsigned char
			unsigned int 	unsigned
			unsigned short	unsigned short int
			unsigned long 	unsigned long int
			unsigned long long 	unsigned long long int
			
			类型 	存储空间大小 	最小值 	最大值
			char 	（与 signed char 或 unsigned char 相同） 	 
			unsigned char 	1个字节 	0 	255
			signed char 	1个字节 	-128 	127
			int 	2个或4个字节 	-32 768 或 -2 147 483 648 	32767 或 2 147 483 647
			unsigned int 	2个或4个字节 	0 	65 535 或 4 294 967 295
			short 	2个字节 	-32 768 	32 767
			unsigned short 	2个字节 	0 	65 535
			long 	4个字节 	-2 147 483 648 	2 147 483 647
			unsigned long 	4个字节 	0 	4 294 967 295
			long long (C99) 	8个字节 	-9 223 372 036 854 775 808 	9 223 372 036 854 775 807
			Unsigned long long (C99) 	8个字节 	0 	18 446 744 073 709 551 615
			
			
#### C语言void关键字详解			
		void类型修饰符（type specifier）表示“没有值可以获得”。因此，不可以采用这个类型声明变量或常量。void 类型可以用于下面各小节所描述的目的。 		
		1、void用于函数声明	
			没有返回值的函数，其类型为 void。
			    void perror( const char * );
		2、void类型表达式
			void 类型表达式指的是没有值的表达式。
		3、指向void的指针	
			一个 void* 类型的指针代表了对象的地址，但没有该对象的类型信息。
		
#### static 变量
		static 关键字不仅可以用来修饰变量，还可以用来修饰函数。在使用 static 关键字修饰变量时，我们称此变量为静态变量。
		1、隐藏与隔离的作用
			全局变量虽然属于静态存储方式，但并不是静态变量。
			全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，全局变量在各个源文件中都是有效的。
		2、保持变量内容的持久性
			我们希望函数中局部变量的值在函数调用结束之后不会消失，而仍然保留其原值。
		3、默认初始化为 0
			在静态数据区，内存中所有的字节默认值都是 0x00


#### |和||的区别详解 *运算符和&运算符
		“||”是逻辑操作符（或），它的操作数是布尔型，即只有“0”（表示 false）和“1”（表示 true）两个数值。C 语言规定，在逻辑运算中，所有非 0 的数值都被看成 1 处理。
		而“|”是位操作符（或），其操作数是位序列。位序列可以是字符型、整型与长短整型等（通常情况下选择无符号整型）。
		
		取址运算符&用来取得其操作数的地址。如果操作数 x 的类型为 T，则表达式 &x 的类型是 T 类型指针（指向 T 的指针）。
		取址运算符的操作数必须是在内存中可寻址到的地址。换句话说，该运算符只能用于函数或对象（例如左值），而不可以用于位字段，以及那些还未被存储类修饰符 register 声明的内容。
		当已具有一个指针，并且希望获取它所引用的对象时，使用间接运算符 *（indirection operator），有时候这会被称为解引用运算符（dereferencing operator）。它的操作数必须是指针类型。如果 ptr 是指针，那么 *ptr 就是 ptr 所指向的对象或函数。
		    float x, *ptr = &x;
			*ptr = 1.7;                                      // 将1.7赋值给变量x
			++(*ptr);                                        // 并将变量x的值加1
		
		
		逗号运算符(，)
		逗号运算符是二元运算符：
			表达式1 , 表达式2
		逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果。
		x = 2.7, sqrt( 2*x )
		在上述表达式中，在 sqrt（）函数被调用之前，赋值运算会首先发生。整个表达式的值是此函数的返回值。

		
		
### 流程控制
		****** if else	
		if(表达式) {语句}
		if (表达式1)
		{
			表达式2;
		}
		else
		{
			表达式3;
		}
		if…else if…else
		
		******* switch case语句
		switch (表达式)
		{
			case 常量表达式1：    语句1
			case 常量表达式2：    语句2
			   ┇
			case 常量表达式n：    语句n
			default:        语句n+1
		}
		1) switch 后面括号内的“表达式”必须是整数类型。也就是说可以是 int 型变量、char 型变量，也可以直接是整数或字符常量，哪怕是负数都可以。但绝对不可以是实数，float 型变量、double 型变量、小数常量通通不行，全部都是语法错误。

		2) switch 下的 case 和 default 必须用一对大括号{}括起来。
		3)当switch后面括号内“表达式”的值与某个case后面的“常量表达式”的值相等时，就执行此case后面的语句。执行完一个case后面的语句后，流程控制转移到下一个case继续执行。如果你只想执行这一个case语句，不想执行其他case，那么就需要在这个case语句后面加上break，跳出switch语句。

		4) 若所有的 case 中的常量表达式的值都没有与 switch 后面括号内“表达式”的值相等的，就执行 default 后面的语句，default 是“默认”的意思。如果 default 是最后一条语句的话，那么其后就可以不加 break，因为既然已经是最后一句了，则执行完后自然就退出 switch 了。

		5) 每个 case 后面“常量表达式”的值必须互不相同，否则就会出现互相矛盾的现象，而且这样写造成语法错误。

		6) “case常量表达式”只是起语句标号的作用，并不是在该处进行判断。在执行 switch 语句时，根据 switch 后面表达式的值找到匹配的入口标号，就从此标号开始执行下去，不再进行判断。

		7) 各个 case 和 default 的出现次序不影响执行结果。但从阅读的角度最好是按字母或数字的顺序写。

		8) 当然你也可以不要 default 语句，就跟 if…else 最后不要 else 语句一样。但最好是加上，后面可以什么都不写。这样可以避免别人误以为你忘了进行 default 处理，而且可以提醒别人 switch 到此结束了。
		
		
		
		******* for
		for (表达式1; 表达式2; 表达式3)
		{
				语句;
		}
		
		******* while
		while (表达式)
		{
				语句；
		}
		当表达式为真，则执行下面的语句；语句执行完之后再判断表达式是否为真，如果为真，再次执行下面的语句；然后再判断表达式是否为真……就这样一直循环下去，直到表达式为假，跳出循环。这个就是 while 的执行顺序。
		
		
		
		******
		break 和 continue
			break 语句，它不仅可以跳出“循环体”，还可以跳出 switch。但事实上，break 也只能用于这两种情况。break 语句不能用于循环语句和 switch 语句之外的任何其他语句中。
			但是 break 只能跳出一层循环。当有多层循环嵌套的时候，break只能跳出“包裹”它的最里面的那一层循环，无法一次跳出所有循环。
		
		continue 的用法十分简单，其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，然后进行下一次是否执行循环的判定。
		
		continue和break的区别
		continue 语句和 break 语句的区别是，continue 语句只结束本次循环，而不是终止整个循环。break 语句则是结束整个循环过程，不再判断执行循环的条件是否成立。而且，continue 只能在循环语句中使用，即只能在 for、while 和 do…while 中使用，除此之外 continue 不能在任何语句中使用。

		
		getchar();  
		/*用getchar吸收回车, 简单、方便、好用, 			都不需要定义变量用来存储获取的回车符*/
        ch = getchar();  //用getchar从缓冲区中读取一个字符赋给字符变量ch
		之前我们先用 getchar() 清空缓冲区，然后重新从键盘输入一个字符。同样，必须按回车 getchar() 才会进去取这个字符
		通过获取的字符进行判断
		
		清空缓冲区只需加一句 fflush(stdin)
		fflush 是包含在文件 stdio.h 中的函数。stdin 是“标准输入”的意思。std 即 standard（标准），in 即 input（输入），合起来就是标准输入。
		fflush(stdin) 的功能是：清空输入缓冲区。
		


### C语言数组		 
		同一数组中存储的数必须满足以下两个条件：
		这些数的类型必须相同。
		这些数在内存中必须是连续存储的。
		换句话说，数组是在内存中连续存储的具有相同类型的一组数据的集合。
		
		一维数组
			类型说明符 数组名[常量表达式];
			int a[5];
				它表示定义了一个整型数组，数组名为 a，定义的数组称为数组 a。数组名 a 除了表示该数组之外，还表示该数组的首地址
				此时数组 a 中有 5 个元素，每个元素都是 int 型变量，而且它们在内存中的地址是连续分配的。
				这里的元素就是变量的意思，数组中习惯上称为元素。
				数组中的下标是从 0 开始的（而不是 1）。
				这 5 个元素分别为 a[0]、a[1]、a[2]、a[3]、a[4]。其中 a[0]、a[1]、a[2]、a[3]、a[4] 分别表示这 5 个元素的变量名。
		
		一维数组初始化
		1) 定义数组时给所有元素赋初值，这叫“完全初始化”。
			    int a[5] = {1, 2, 3, 4, 5};
		2) 可以只给一部分元素赋值，这叫“不完全初始化”
				int a[5] = {1, 2};
			不完全初始化时，没有被初始化的元素自动为 0。
			需要注意的是，“不完全初始化”和“完全不初始化”不一样。如果“完全不初始化”，即只定义“int a[5]；”而不初始化，那么各个元素的值就不是0了，所有元素都是垃圾值。
			也不能写成“int a[5]={}；”。如果大括号中什么都不写，那就是极其严重的语法错误。
		3) 如果定义数组时就给数组中所有元素赋初值，那么就可以不指定数组的长度，因为此时元素的个数已经确定了
			int a[5] = {1, 2, 3, 4, 5};
			可以写成：
			int a[] = {1, 2, 3, 4, 5};
		
		一维数组元素的引用
		数组必须先定义，然后使用。C 语言规定，只能逐个引用数组元素，而不能一次引用整个数组
			数组名[下标]
		定义数组时用到的“数组名[常量表达式]”和引用数组元素时用到的“数组名[下标]”是有区别的，定义数组时的常量表达式表示的是数组的长度，而引用数组元素时的下标表示的是元素的编号
		
		数组之间的赋值
			正确的写法是用 for 循环，将数组 a 中的元素一个一个赋给数组b的元素：
		    for (i=0; i<5; ++i){
				b[i] = a[i];}
		数组的长度
			使用关键字 sizeof。
			    int a[10] = {0};
				printf("sizeof(a) = %d\n", sizeof(a));
				return 0;
			数组 a 是 int 型的，每个元素占 4 字节，所以长度为 10 的数组在内存中所占的字节数就是 40。		
			
		一维字符数组	
		char 数组名[数组大小];
			char c[10];
			该语句定义了一个一维字符数组 c，大小为 10，即占 10 个字符变量空间，最大可存储长度为 9 的字符串（第 10 个字符为 '0'）。
		
#### define
		用 #define 定义一个标识符来表示一个常量。
		其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。
		预编译又叫预处理。预编译不是编译，而是编译前的处理。这个操作是在正式编译之前由系统自动完成的。
		#define  标识符  常量   //注意, 最后没有分号
		#define又称宏定义，标识符为所定义的宏名，简称宏。
		变量名表示的是一个变量，但宏名表示的是一个常量。可以给变量赋值，但绝不能给常量赋值。
		
		#define NUM 5
		int mian(void){
			int i,j=NUM;
		}
		
		
### 二维数组
		类型说明符 数组名[ 常量表达式][ 常量表达式];
		    int a[3][4];
		表示定义了一个 3×4，即 3 行 4 列总共有 12 个元素的数组 a。
		
		
		
#### 指针与数组的区别		
		指针：
		1、保存数据的地址，任何存入指针变量p的数据都会被当做地址来处理
		2、间接访问数据，首先取得指针变量p的内容，把它当做地址，然后从这个地址提取数据或向这个地址写入数据
		3、通常用于动态数据结构
		4、需要malloc和free等相关的函数进行内存分配
		5、通常指向匿名函数
		数组：
		1、保存数据，数组名a代表的是数组首元素的首地址，&a是整个数组的首地址
		2、直接访问数据，数组名a是整个数组的名字，数组内每个元素并没有名字
		3、通常用于存储固定数据且数据类型相同的元素
		4、隐式分配和删除
		5、自身即为数组名
		
		
### 函数
		第一，函数就是 C 语言的模块，一块一块的，有较强的独立性，可以相互调用，换句话说，C 语言中，一个函数里面可以调用 n 个函数，即大函数调用小函数，小函数又调用“小小”函数。这就是结构化程序设计，所以面向过程的语言又叫结构化语言。
		第二，函数就是一系列 C 语句的集合，能完成某个特定的功能。需要该功能的时候直接调用该函数即可，不用每次都堆叠代码。需要修改该功能时，也只需要修改和维护这一个函数即可。
		
		从形式上看，函数可分为两类：无参函数和有参函数。
		所谓无参函数，是指在主调函数调用被调函数时，主调函数不向被调函数传递数据。无参函数一般用来执行特定的功能，可以有返回值，也可以没有返回值，但一般以没有返回值居多。
		有参函数，是指在主调函数调用被调函数时，主调函数通过参数向被调函数传递数据。在一般情况下，有参函数在执行被调函数时会得到一个值并返回给主调函数使用。
		
		有参函数
		 函数类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, …, 参数类型n 参数名n)
		 {
		    声明部分
		    语句部分
		 }
		int Max(int x, int y)
		
		形参和实参
		函数名 Max 后面括号中的参数 x、y 称为形式参数，简称形参
		而在主调函数 main 中调用 Max 函数时，Max 函数名后面括号中的参数 a、b 称为实际参数，简称实参。
		实参可以是常量、变量或表达式，但它们必须要有确定的数值。
		在定义函数时，必须要指定形参的类型。实参与形参的个数必须相等，若不相等就是语法错误。
		
		
#### 字符串
		一个字符在内存中只占一字节，而字符串本质上是多个字符组成的字符数组。
		C语言规定，在每一个字符串常量的结尾，系统都会自动加一个字符'\0'作为该字符串的“结束标志符”，系统据此判断字符串是否结束。
		"CHINA"有 5 个可见字符，占 6 字节。
		“双撇号”中什么都不写，则只有 '\0' 一个字符，所以只占一字节。
		"你好"占 5 字节，1 个英文字符占 1 字节，而 1个 中文字符占 2 字节，就算是中文的标点符号也是占 2 字节。所以两个汉字占 4 字节，加上 '\0' 总共是 5 字节。
		
		memset函数
			定义变量时一定要进行初始化，尤其是数组和结构体这种占用内存大的数据结构。
			在使用数组的时候经常因为没有初始化而产生乱码
			memset()是初始化内存的万能函数，通常为新申请的内存进行初始化工作
			它是直接操作内存空间，mem即“内存”（memory）的意思。
			函数原型为
				#include <string.h>
				void *memset(void *s,int c,unsigned long n);
					函数的功能是：将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。
				memset() 的作用是在一段内存块中填充某个给定的值。
		
		gets函数
			在前面从键盘输入字符串是使用 scanf 和 %s。其实还有更简单的方法，即使用 gets() 函数。
			函数原型为：
				#include <stdio.h>
				char *gets(char *str);
			    
				printf("请输入字符串：");
				gets(str);	
		
		fgets()函数
			它的功能是从 stream 流中读取 size 个字符存储到字符指针变量 s 所指向的内存空间。它的返回值是一个指针，指向字符串中第一个字符的地址。
			    fgets(str, 7, stdin);  /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/
		
		puts()函数
			该函数的原型为：
			# include <stdio.h>
			int puts(const char *s);
			s可以是字符指针变量名、字符数组名，或者直接是一个字符串常量。
			功能是将字符串输出到屏幕。输出时只有遇到 '\0' 也就是字符串结束标志符才会停止。
		
		strchr 与 strrchr 函数查找单个字符
			它表示在字符串 s 中查找字符 c，返回字符 c 第一次在字符串 s 中出现的位置，如果未找到字符 c，则返回 NULL。
			与 strchr 函数一样，它同样表示在字符串 s 中查找字符 c，返回字符 c 第一次在字符串 s 中出现的位置，如果未找到字符 c，则返回 NULL。
		
		使用 strpbrk 函数查找多个字符
			该函数在源字符串（s1）中按从前到后顺序找出最先含有搜索字符串（s2）中任一字符的位置并返回，空字符 null('\0') 不包括在内，若找不到则返回空指针。
		
		使用 strstr 函数查找一个子串
			strstr 函数表示在字符串 haystack 中从前到后查找子串 needle 第一次出现的位置（不比较结束符 null('\0')），并返回指向第一次出现 needle 位置的指针，如果没找到则返回 NULL。
		
		
### 结构体
		结构体是将不同类型的数据按照一定的功能需求进行整体封装，封装的数据类型与大小均可以由用户指定。
		声明结构体类型
		struct结构体名
		{
			成员列表
		}；
		struct STUDENT
		{
			char name[20];
			int num;
			char sex;
			int age;
			float score;
		
		};   //分号千万不能省略
		
		1) 最后的分号千万不能省略。为了防止最后忘记分号，最好先将框架写出来，写的时候直接把分号加上： 
		2) 结构体类型是由一些基本数据类型组合而成的新的数据类型。
		3) struct 是声明结构体类型时必须使用的关键字，不能省略。
		4) struct STUDENT 是定义的数据类型的名字，它向编译系统声明这是一个“结构体类型”
		5) struct STUDENT 与系统提供的 int、char、float、double 等标准类型名一样，都是数据类型，具有同样的作用，都是用来定义变量的。
		6) “结构体名”的命名规范是全部使用大写字母。
		7) “结构体名”是结构体类型的标志。
		8) 声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存，就如同系统不会为类型 int 分配内存一样。
		
		结构体变量可进行哪些运算
			结构体变量不能相加、不能相减，也不能相互乘除，但结构体变量可以相互赋值。也就是说，可以将一个结构体变量赋给另一个结构体变量。但前提是这两个结构体变量的结构体类型必须相同。
		
		结构体变量的引用
			1) 不能将一个结构体变量作为一个整体进行引用，只能分别单独引用它内部的成员，引用方式为：
				结构体变量名.成员名
				如果成员名是一个变量名，那么引用的就是这个变量的内容；如果成员名是一个数组名，那么引用的就是这个数组的首地址。
				student1.num = 1207041;
			2) 如果结构体类型中的成员也是一个结构体类型，则要用若干个“.”，一级一级地找到最低一级的成员。因为只能对最低级的成员进行操作。
			3) 可以引用“结构体变量成员”的地址，也可以引用“结构体变量”的地址。
			4) 结构体变量的引用方式决定了： 
				 “结构体变量名”可以与“结构体成员名”同名。
				“结构体变量名”可以与“结构体名”同名。
				“两个结构体类型定义的结构体变量中的成员可以同名”
			struct AGE
			{
				int year;
				int month;
				int day;
			};
			struct STUDENT
			{
				char name[20];
				int num;
				struct AGE birthday;  //就有点类似于C++中的封装了
				float score;
			};
			struct STUDENT student1 = {"小明", 1207041, {1989, 3, 29}, 100};
		
		结构体变量的初始化
		**  struct STUDENT student1 = {"小明", 1207041, {1989, 3, 29}, 100};
		**   struct STUDENT student1;
		    strcpy(student1.name, "小明");  //不能写成&student1
			student1.num = 1207041;
			student1.birthday.year = 1989;
			student1.birthday.month = 3;
			student1.birthday.day = 29;
			student1.score = 100;
		
		typedef
			1、为基本数据类型定义新的类型名
				typedef unsigned int COUNT;
			2、为自定义数据类型(结构体、共用体和枚举类型)定义简洁的类型名称
			3、为数组定义简洁的类型名称	
				typedef int INT_ARRAY_100[100];
			4、 为指针定义简洁的名称
				typedef char* PCHAR
		
				
		
		
		
		
		
		
		
		
		
		
		
		